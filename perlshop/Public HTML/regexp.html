<!DOCTYPE HTML PUBLIC 
	"-//W3C//DTD HTML 4.0 Transitional//EN" 
	"http://www.w3.org/TR/REC-html40/loose.dtd">

<HTML>
<head>
<TITLE>Perl Regular Expressions</TITLE>
<link rel=stylesheet type="text/css" 
	href="http://www.waveridersystems.com/globalstyle.css">
</head>

<body bgcolor="white">
<p>
<H2> 
<A NAME="perlre_regular_0">
Regular Expressions</A>
</H2>
<hr>
The patterns used in pattern matching are regular expressions such as
those supplied in the Version 8 regexp routines.  (In fact, the
routines are derived (distantly) from Henry Spencer's freely
redistributable reimplementation of the V8 routines.)
See 
<A HREF="#perlre_version_0"><EM>Version 8 Regular Expressions</EM></A>
 for details.
<p>In particular the following metacharacters have their standard <EM>egrep</EM>-ish
meanings:
<p>
<XMP>
    \   Quote the next metacharacter
    ^   Match the beginning of the line
    .   Match any character (except newline)
    $   Match the end of the line
    |   Alternation
    ()  Grouping
    []  Character class

</XMP>
<p>By default, the "^" character is guaranteed to match only at the
beginning of the string, the "$" character only at the end (or before the
newline at the end) and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by "^" or "$".  You may, however, wish to treat a
string as a multi-line buffer, such that the "^" will match after any
newline within the string, and "$" will match before any newline.  At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.  (Older programs did this by setting 
$*
,
but this practice is deprecated in Perl 5.)
<p>To facilitate multi-line substitutions, the "." character never matches a
newline unless you use the <CODE>/s</CODE> modifier, which tells Perl to pretend
the string is a single line--even if it isn't.  The <CODE>/s</CODE> modifier also
overrides the setting of 
$*
, in case you have some (badly behaved) older
code that sets it in another module.
<p>The following standard quantifiers are recognized:
<p>
<XMP>
    *      Match 0 or more times
    +      Match 1 or more times
    ?      Match 1 or 0 times
    {n}    Match exactly n times
    {n,}   Match at least n times
    {n,m}  Match at least n but not more than m times

</XMP>
<p>(If a curly bracket occurs in any other context, it is treated
as a regular character.)  The "*" modifier is equivalent to <CODE>{0,}</CODE>, the "+"
modifier to <CODE>{1,}</CODE>, and the "?" modifier to <CODE>{0,1}</CODE>.  There is no limit to the
size of n or m, but large numbers will chew up more memory. 
<p>By default, a quantified subpattern is "greedy", that is, it will match as
many times as possible without causing the rest pattern not to match.  The
standard quantifiers are all "greedy", in that they match as many
occurrences as possible (given a particular starting location) without
causing the pattern to fail.  If you want it to match the minimum number
of times possible, follow the quantifier with a "?" after any of them.
Note that the meanings don't change, just the "gravity":
<p>
<XMP>
    *?     Match 0 or more times
    +?     Match 1 or more times
    ??     Match 0 or 1 time
    {n}?   Match exactly n times
    {n,}?  Match at least n times
    {n,m}? Match at least n but not more than m times

</XMP>
<p>Since patterns are processed as double quoted strings, the following
also work:
<p>
<XMP>
    \t          tab
    \n          newline
    \r          return
    \f          form feed
    \v          vertical tab, whatever that is
    \a          alarm (bell)
    \e          escape
    \033        octal char
    \x1b        hex char
    \c[         control char
    \l          lowercase next char
    \u          uppercase next char
    \L          lowercase till \E
    \U          uppercase till \E
    \E          end case modification
    \Q          quote regexp metacharacters till \E

</XMP>
<p>In addition, Perl defines the following:
<p>
<XMP>
    \w  Match a "word" character (alphanumeric plus "_")
    \W  Match a non-word character
    \s  Match a whitespace character
    \S  Match a non-whitespace character
    \d  Match a digit character
    \D  Match a non-digit character

</XMP>
<p>Note that <CODE>\w</CODE> matches a single alphanumeric character, not a whole
word.  To match a word you'd need to say <CODE>\w+</CODE>.  You may use <CODE>\w</CODE>, <CODE>\W</CODE>, <CODE>\s</CODE>,
<CODE>\S</CODE>, <CODE>\d</CODE> and <CODE>\D</CODE> within character classes (though not as either end of a
range).
<p>Perl defines the following zero-width assertions:
<p>
<XMP>
    \b  Match a word boundary
    \B  Match a non-(word boundary)
    \A  Match only at beginning of string
    \Z  Match only at end of string
    \G  Match only where previous m//g left off

</XMP>
<p>A word boundary (<CODE>\b</CODE>) is defined as a spot between two characters that
has a <CODE>\w</CODE> on one side of it and and a <CODE>\W</CODE> on the other side of it (in
either order), counting the imaginary characters off the beginning and
end of the string as matching a <CODE>\W</CODE>.  (Within character classes <CODE>\b</CODE>
represents backspace rather than a word boundary.)  The <CODE>\A</CODE> and <CODE>\Z</CODE> are
just like "^" and "$" except that they won't match multiple times when the
<CODE>/m</CODE> modifier is used, while "^" and "$" will match at every internal line
boundary.
<p>When the bracketing construct <CODE>( ... )</CODE> is used, &lt;digit&gt; matches the
digit'th substring.  (Outside of the pattern, always use "$" instead of
"\" in front of the digit.  The scope of &lt;digit&gt; (and 
$`
, <CODE>$&amp;</CODE>, and <CODE>$')</CODE>
extends to the end of the enclosing BLOCK or eval string, or to the
next pattern match with subexpressions.  
If you want to
use parentheses to delimit subpattern (e.g. a set of alternatives) without
saving it as a subpattern, follow the ( with a ?.
The &lt;digit&gt; notation
sometimes works outside the current pattern, but should not be relied
upon.)  You may have as many parentheses as you wish.  If you have more
than 9 substrings, the variables <STRONG>$10</STRONG>, <STRONG>$11</STRONG>, ... refer to the
corresponding substring.  Within the pattern, \10, \11, etc. refer back
to substrings if there have been at least that many left parens before
the backreference.  Otherwise (for backward compatibilty) \10 is the
same as \010, a backspace, and \11 the same as \011, a tab.  And so
on.  (\1 through \9 are always backreferences.)
<p>
$+
 returns whatever the last bracket match matched.  <CODE>$&amp;</CODE> returns the
entire matched string.  (
$0
 used to return the same thing, but not any
more.)  
$`
 returns everything before the matched string.  
$'
 returns
everything after the matched string.  Examples:
<p>
<XMP>
    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
    if (/Time: (..):(..):(..)/) {
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }

</XMP>
<p>You will note that all backslashed metacharacters in Perl are
alphanumeric, such as <CODE>\b</CODE>, <CODE>\w</CODE>, <CODE>\n</CODE>.  Unlike some other regular expression
languages, there are no backslashed symbols that aren't alphanumeric.
So anything that looks like \\, \(, \), &lt;, \&gt;, \{, or \} is always
interpreted as a literal character, not a metacharacter.  This makes it
simple to quote a string that you want to use for a pattern but that
you are afraid might contain metacharacters.  Simply quote all the
non-alphanumeric characters:
<p>
<XMP>
    $pattern =~ s/(\W)/\\$1/g;

</XMP>
<p>You can also use the built-in 
quotemeta()
 function to do this.
An even easier way to quote metacharacters right in the match operator
is to say 
<p>
<XMP>
    /$unquoted\Q$quoted\E$unquoted/

</XMP>
<p>Perl 5 defines a consistent extension syntax for regular expressions.
The syntax is a pair of parens with a question mark as the first thing
within the parens (this was a syntax error in Perl 4).  The character
after the question mark gives the function of the extension.  Several
extensions are already supported:
<p>
<DL>
<DT><STRONG>

<A NAME="perlre_text_0">
(?#text)</A>

</STRONG></DT>
<DD>

A comment.  The text is ignored.
<p></DD>
<DT><STRONG>

<A NAME="perlre_regexp_0">
(?:regexp)</A>

</STRONG></DT>
<DD>

This groups things like "()" but doesn't make backrefences like "()" does.  So
<p>
<XMP>
    split(/\b(?:a|b|c)\b/)

</XMP>
<p>is like
<p>
<XMP>
    split(/\b(a|b|c)\b/)

</XMP>
<p>but doesn't spit out extra fields.
<p></DD>
<DT><STRONG>

<A NAME="perlre_regexp_1">
(?=regexp)</A>

</STRONG></DT>
<DD>

A zero-width positive lookahead assertion.  For example, <CODE>/\w+(?=\t)/</CODE>
matches a word followed by a tab, without including the tab in <CODE>$&amp;</CODE>.
<p></DD>
<DT><STRONG>

<A NAME="perlre_regexp_2">
(?!regexp)</A>

</STRONG></DT>
<DD>

A zero-width negative lookahead assertion.  For example <CODE>/foo(?!bar)/</CODE>
matches any occurrence of "foo" that isn't followed by "bar".  Note
however that lookahead and lookbehind are NOT the same thing.  You cannot
use this for lookbehind: <CODE>/(?!foo)bar/</CODE> will not find an occurrence of
"bar" that is preceded by something which is not "foo".  That's because
the <CODE>(?!foo)</CODE> is just saying that the next thing cannot be "foo"--and
it's not, it's a "bar", so "foobar" will match.  You would have to do
something like <CODE>/(?foo)...bar/</CODE> for that.   We say "like" because there's
the case of your "bar" not having three characters before it.  You could
cover that this way: <CODE>/(?:(?!foo)...|^..?)bar/</CODE>.  Sometimes it's still 
easier just to say:
<p>
<XMP>
    if (/foo/ && $` =~ /bar$/) 

</XMP>
<p></DD>
<DT><STRONG>

<A NAME="perlre_imsx_0">
(?imsx)</A>

</STRONG></DT>
<DD>

One or more embedded pattern-match modifiers.  This is particularly
useful for patterns that are specified in a table somewhere, some of
which want to be case sensitive, and some of which don't.  The case
insensitive ones merely need to include <CODE>(?i)</CODE> at the front of the
pattern.  For example:
<p>
<XMP>
    $pattern = "foobar";
    if ( /$pattern/i ) 
    # more flexible:
    $pattern = "(?i)foobar";
    if ( /$pattern/ ) 

</XMP>
<p></DD>
</DL>
The specific choice of question mark for this and the new minimal.matching construct was because 1) question mark is pretty rare in older
regular expressions, and 2) whenever you see one, you should stop
and "question" exactly what is going on.  That's psychology...
<p>
<H2> 
<A NAME="perlre_version_0">
Version 8 Regular Expressions</A>
</H2>

In case you're not familiar with the "regular" Version 8 regexp
routines, here are the pattern-matching rules not described above.
<p>Any single character matches itself, unless it is a <EM>metacharacter</EM>
with a special meaning described here or above.  You can cause
characters which normally function as metacharacters to be interpreted
literally by prefixing them with a "\" (e.g. "\." matches a ".", not any
character; "\\" matches a "\").  A series of characters matches that
series of characters in the target string, so the pattern <CODE>blurfl</CODE>
would match "blurfl" in the target string.
<p>You can specify a character class, by enclosing a list of characters
in <CODE>[]</CODE>, which will match any one of the characters in the list.  If the
first character after the "[" is "^", the class matches any character not
in the list.  Within a list, the "-" character is used to specify a
range, so that <CODE>a-z</CODE> represents all the characters between "a" and "z",
inclusive.
<p>Characters may be specified using a metacharacter syntax much like that
used in C: "\n" matches a newline, "\t" a tab, "\r" a carriage return,
"\f" a form feed, etc.  More generally, \<EM>nnn</EM>, where <EM>nnn</EM> is a string
of octal digits, matches the character whose ASCII value is <EM>nnn</EM>.
Similarly, \x<EM>nn</EM>, where <EM>nn</EM> are hexidecimal digits, matches the
character whose ASCII value is <EM>nn</EM>. The expression \c<EM>x</EM> matches the
ASCII character control-<EM>x</EM>.  Finally, the "." metacharacter matches any
character except "\n" (unless you use <CODE>/s</CODE>).
<p>You can specify a series of alternatives for a pattern using "|" to
separate them, so that <CODE>fee|fie|foe</CODE> will match any of "fee", "fie",
or "foe" in the target string (as would <CODE>f(e|i|o)e</CODE>).  Note that the
first alternative includes everything from the last pattern delimiter
("(", "[", or the beginning of the pattern) up to the first "|", and
the last alternative contains everything from the last "|" to the next
pattern delimiter.  For this reason, it's common practice to include
alternatives in parentheses, to minimize confusion about where they
start and end.  Note however that "|" is interpreted as a literal with
square brackets, so if you write <CODE>[fee|fie|foe]</CODE> you're really only
matching <CODE>[feio|]</CODE>.
<p>Within a pattern, you may designate subpatterns for later reference by
enclosing them in parentheses, and you may refer back to the <EM>n</EM>th
subpattern later in the pattern using the metacharacter \<EM>n</EM>. 
Subpatterns are numbered based on the left to right order of their
opening parenthesis.  Note that a backreference matches whatever
actually matched the subpattern in the string being examined, not the
rules for that subpattern.  Therefore, <CODE>(0|0x)\d*\s\1\d*</CODE> will
match "0x1234 0x4321",but not "0x1234 01234", since subpattern 1
actually matched "0x", even though the rule <CODE>0|0x</CODE> could
potentially match the leading 0 in the second number.
<p>
</HTML>
